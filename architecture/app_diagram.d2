vars: {
  d2-config: {
    # sketch: true
    layout-engine: elk
  }
}
direction: right
classes: {
  task: {
    style: {
      fill: lightgreen
    }
  } 
  channel: {
    style: {
      fill: pink
    }
    shape: queue
    width: 200
  }
  client: {style: {fill: yellow}}
  ocpp: {
    style: {fill: lightblue}
  }
  network: {
    # width: 550
  }
  app: {
    style: {fill: "#ddddee"}
  }
  fsm: {
    style: {fill: "#6699cc"}
  }
  legend: {
    style: {
      stroke: "#ddddee"
      fill: "#ddddee"
    }
  }
  charger: {
    label: ""
    shape: image
    icon: "./charging-station.png"
    style: {
      fill: "#6699cc"
      stroke: "#6699cc"
    }
  }
  placeholder: {
    label: ""
    style: {
      fill: "#6699cc"
      stroke: "#6699cc"
    }
    width: 120
    height: 60
  }
  state-box: {
    width: 120
    height: 60
  }
  states: {
    label: ""
    style: {
      fill: "#6699cc"
      stroke: "#6699cc"
    }    
  }
  code: {
    style: {
      fill: lightgreen
    }
  }
}

Main.class: app
Main: Application Clients, Tasks and Channels {
  grid-columns: 3
  Charger State Machine.class: fsm
  Charger State Machine: {
    States.class: states
    States {
      grid-rows: 2
      grid-gap: 15
      available.class: state-bo
      available: {style: {fill: lightgreen}}
      occupied: {width: 120; style: {fill: lightyellow}}
      authorizing: {width: 120; style: {fill: orange}}
      charging.class: state-box
      charging: {style: {fill: lightblue}}
      faulted.class: state-box
      faulted: {style: {fill: pink}}
      off.class: state-box
      off: {style: {fill: lightgrey}}
    }
    charger.class: charger 
  }
  State Machine Handler.class: task
  State Machine Handler{
    grid-columns: 1
    grid-gap: 0
    box: |md
      - handles state transitions based on input events
      - uses a finite state machine to manage charger states
      - communicates state changes via State Out Channel
      |
    code.class: code
    code: |rust
      fn transition(state: ChargerState, event: InputEvent) -> ChargerState {
        match (state, event) {
          (ChargerState::Available, InputEvent::InsertCable) => ChargerState::Occupied,
          (ChargerState::Occupied, InputEvent::RemoveCable) => ChargerState::Available,
          // other transitions
          _ => ChargerState::Faulted,
        }
      }| 
  }
  Network.class: network
  Network: {
    grid-columns: 1
    grid-gap: 45
    Wifi Connection.class: task
    Wifi Connection.box: |md
      Handles opening and reconnecting the wifi connection
    |
    Runner.class: task
    Runner.bos: |md
      runs embassy's network stack
    |
  }
  NTP CLient.class: client
  NTP CLient.box: |md
    - handles communication with NTP Server
    - uses local timer for time since last sync point 
  |
  NTP Sync.class: task
  NTP Sync.box: |md
    periodically syncs time with NTP Server
  |
  ESP32-C6: {
    shape: image
    label: "XIAO ESP32-C6"
    icon: "./esp32-c6.png"
    style: {
      fill: "#6699cc"
      stroke: "#6699cc"
    }
    height: 200

  }
  State Out Channel.class: channel
  State Out Channel.box: |md
    Threadsafe channel for propagating state changes
  |
  State In Channel.class: channel
  State In Channel.box: |md
    Threadsafe channel to send events that changes state
  |
  OCPP Response Handler.class: ocpp
  OCPP Response Handler.box: |md
    receives and handles ocpp Responses
  |
  OCPP Receive Channel.class: channel
  OCPP Receive Channel.box: |md
    Threadsafe channel to handle incoming messages
  |
  MQTT Client.class: client
  MQTT Client.box: |md
    - handles communication with an MQTT Broker
    - TODO: Secure connection with TLS
  |
  OCPP Send Channel.class: channel
  OCPP Send Channel.box: |md
    Threadsafe channel to handle outgoing messages
  |
  Hardware: {
    grid-columns: 2
    grid-rows: 5
    Led Handler.class: task
    Led Handler.box: |md
      - controls multicolor led
      - GPIO15 (going to RGB LED)
    |
    Relais Handler.class: task
    Relais Handler.box: |md
      - controls the relais
      - GPIO2
    |
    Swipe Handler.class: task
    Swipe Handler.box: |md
      - Monitors rfid card swipes
      - GPIO1 (going to be SPI GPIO17-20) 
    |
    Cable Detection Handler.class: task
    Cable Detection Handler.box: |md
      - Monitors cable connection status
      - GPIO0
    |
    Display Handler.class: task
    Display Handler.box: |md
      - Display Charger State and Network info
      - runs in main loop
      - I2C (GPIO22-23)
    |
    Led {
      label: ""
      icon: "./led.png"
    }
    Relais {
      label: ""
      icon: "./circuit.png"
    }
    RFID {
      label: ""
      icon: "./money.png"
    }
    Cable {
      label: ""
      icon: "./vehicle.png"
    }
    Display {
      label: ""
      icon: "./display-frame.png"
    }
  }
  Statusnotification Handler.class: ocpp
  Statusnotification Handler.box: |md
    Sends status notification on charger state changes
  |
  Bootnotification Handler.class: ocpp
  Bootnotification Handler.box: |md
    Sends BootNotification Request on startup
  |
  HeartBeat Handler.class: ocpp
  HeartBeat Handler.box: |md
    Periodically sends Heartbeat Request
  |
  State Out Channel -> Hardware.Led Handler -> Hardware.LED
  State Out Channel -> Hardware.Relais Handler -> Hardware.Relais
  State In Channel -> State Machine Handler -> State Out Channel 
  Hardware.RFID -> Hardware.Swipe Handler -> State In Channel
  Hardware.Cable -> Hardware.Cable Detection Handler -> State In Channel
  Hardware.Display Handler -> Hardware.Display
  OCPP Receive Channel -> OCPP Response Handler -> State In Channel
  NTP Sync -> NTP CLient
  OCPP Send Channel -> MQTT Client -> OCPP Receive Channel
  HeartBeat Handler -> OCPP Send Channel
  Bootnotification Handler -> OCPP Send Channel
  State Machine Handler <-> Charger State Machine
  State Out Channel -> Statusnotification Handler -> OCPP Send Channel
  NTP Client <-> Network
  MQTT Client <-> Network
}

Legend.class: legend
Legend: {
  grid-rows: 1
  near: bottom-center
  task.class: task
  channel.class: channel
  client.class: client
  ocpp.class: ocpp
  fsm.class: fsm
}